from motors import MotorController
from lidar import Lidar
from direction import DirectionManager
import RPi.GPIO as GPIO
import traceback
import time

import math

if __name__ == "__main__":
	
	GPIO.setmode(GPIO.BCM)
	motors = MotorController()
	lidar = Lidar()
	directions = DirectionManager(4*math.pi/3, math.pi, 300)
	num_scans = 5
	turn = 0

	running = True
	while running:
		try:
			# make sure we are stationary
			#motors.stopAllMotors()
			
			# Get some scans
			scans = lidar.scan(num_scans)

			# Process the scans 
			directions.filter_scansAlg180(scans)
			# Get the variables we need to make decisions with 
			print(directions.filteredScansAngle)
			
			x2 = 500 #upperDistance 
			x1 = 100 #lowerDistance
			currentDistance = directions.filteredScansAngle180.get(math.pi/2) #gets the distance at angle 180
			h = directions.filteredScansAngle180.get(4*math.pi/3) #gets the distance at angle 135
			

			print(x2)
			print(x1)
			mag = 0.25

			#Include turn
			if currentDistance > x1 and currentDistance < x2: #if the car is between both distance we do minor turns
				angle = math.pi/2 #set the angle to 90
				if currentDistance > (x2 - x1)/2:
					#turn left
					turn = -.5
				elif currentDistance < (x2 - x1)/2:
					#turn right
					turn = .5
			elif currentDistance > x2:	#if the car is passed x2 the car moves left to get back into the center			
				angle = 90 + math.atan2(math.sqrt(h**2+currentDistance**2)/currentDistance)				
			elif currentDistance < x1: #if the car is passed x1 the car moves right to get back into the center		
				angle = 90 - math.atan2(math.sqrt(h**2+currentDistance**2)/currentDistance)	



#everything is kept the same here
				print(turn)
				power1 = (math.sin((angle)-(1/4)*math.pi))
				power2 = (math.sin((angle)+(1/4)*math.pi)) 
				
				our_max = max(abs(power1), abs(power2))
				a_power = mag*power2/our_max - turn
				b_power = mag*power1/our_max + turn
				d_power = mag*power1/our_max - turn
				c_power = mag*power2/our_max + turn
				
				
				
				if (mag + abs(turn) > 1):
					a_power /= mag + abs(turn)
					b_power /= mag + abs(turn)
					c_power /= mag + abs(turn)
					d_power /= mag + abs(turn)
				
				a_power *= 100
				b_power *= 100
				c_power *= 100
				d_power *= 100
			
			
				"""			print(f"Angle: {angle}")
				print(f"a_power: {a_power}") 
				print(f"b_power: {b_power}") 
				print(f"c_power: {c_power}")
				print(f"d_power: {d_power}") 
				
				"""
			

				motors.setMotorPower(motors.forwardA, motors.backwardA, motors.pwmA, a_power)
				motors.setMotorPower(motors.forwardB, motors.backwardB, motors.pwmB, b_power)
				motors.setMotorPower(motors.forwardC, motors.backwardC, motors.pwmC, c_power)
				motors.setMotorPower(motors.forwardD, motors.backwardD, motors.pwmD, d_power)

			else:
				turn = 0
			
			time.sleep(0.1)
		
			
		except KeyboardInterrupt:
			print("Exiting for keyboard interrupt")
			motors.cleanup()
			lidar.disconnect()
			running = False
		
		except Exception as e:
			print("Error")
			print(e)
			traceback.print_exc()
			lidar.disconnect()
			running = False